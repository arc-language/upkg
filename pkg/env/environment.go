// pkg/env/environment.go
package env

import (
    "fmt"
    "os"
    "path/filepath"
    "strings"
)

// New creates a new environment
func New(installPath, backendType string) *Environment {
    return &Environment{
        InstallPath: installPath,
        BackendType: backendType,
    }
}

// GetLibraryPaths returns absolute paths to library directories
func (e *Environment) GetLibraryPaths() []string {
    layout := GetPackageLayout(e.BackendType)
    
    paths := make([]string, 0, len(layout.Libraries))
    for _, relPath := range layout.Libraries {
        absPath := filepath.Join(e.InstallPath, relPath)
        // Only include if directory exists
        if dirExists(absPath) {
            paths = append(paths, absPath)
        }
    }
    
    return paths
}

// GetIncludePaths returns absolute paths to include directories
func (e *Environment) GetIncludePaths() []string {
    layout := GetPackageLayout(e.BackendType)
    
    paths := make([]string, 0, len(layout.Includes))
    for _, relPath := range layout.Includes {
        absPath := filepath.Join(e.InstallPath, relPath)
        if dirExists(absPath) {
            paths = append(paths, absPath)
        }
    }
    
    return paths
}

// GetPkgConfigPaths returns absolute paths to pkg-config directories
func (e *Environment) GetPkgConfigPaths() []string {
    layout := GetPackageLayout(e.BackendType)
    
    paths := make([]string, 0, len(layout.PkgConfig))
    for _, relPath := range layout.PkgConfig {
        absPath := filepath.Join(e.InstallPath, relPath)
        if dirExists(absPath) {
            paths = append(paths, absPath)
        }
    }
    
    return paths
}

// GetBinaryPaths returns absolute paths to binary directories
func (e *Environment) GetBinaryPaths() []string {
    layout := GetPackageLayout(e.BackendType)
    
    paths := make([]string, 0, len(layout.Binaries))
    for _, relPath := range layout.Binaries {
        absPath := filepath.Join(e.InstallPath, relPath)
        if dirExists(absPath) {
            paths = append(paths, absPath)
        }
    }
    
    return paths
}

// GetCompilerFlags generates compiler flags for this environment
func (e *Environment) GetCompilerFlags() *CompilerFlags {
    flags := &CompilerFlags{
        IncludeFlags: make([]string, 0),
        LibraryFlags: make([]string, 0),
        LinkFlags:    make([]string, 0),
    }
    
    // Add include paths
    for _, path := range e.GetIncludePaths() {
        flags.IncludeFlags = append(flags.IncludeFlags, "-I"+path)
    }
    
    // Add library search paths
    for _, path := range e.GetLibraryPaths() {
        flags.LibraryFlags = append(flags.LibraryFlags, "-L"+path)
    }
    
    return flags
}

// GetLinkerFlags returns linker flags as a slice of strings
func (e *Environment) GetLinkerFlags() []string {
    flags := make([]string, 0)
    for _, path := range e.GetLibraryPaths() {
        flags = append(flags, "-L"+path)
    }
    return flags
}

// GetIncludeFlags returns include flags as a slice of strings
func (e *Environment) GetIncludeFlags() []string {
    flags := make([]string, 0)
    for _, path := range e.GetIncludePaths() {
        flags = append(flags, "-I"+path)
    }
    return flags
}

// BuildEnv builds environment variables for subprocess execution
func (e *Environment) BuildEnv() []string {
    env := os.Environ() // Start with current environment
    
    libPaths := e.GetLibraryPaths()
    includePaths := e.GetIncludePaths()
    binPaths := e.GetBinaryPaths()
    pkgConfigPaths := e.GetPkgConfigPaths()
    
    // Prepend paths to existing env vars
    env = prependEnvVar(env, "LD_LIBRARY_PATH", strings.Join(libPaths, ":"))
    env = prependEnvVar(env, "LIBRARY_PATH", strings.Join(libPaths, ":"))
    env = prependEnvVar(env, "C_INCLUDE_PATH", strings.Join(includePaths, ":"))
    env = prependEnvVar(env, "CPLUS_INCLUDE_PATH", strings.Join(includePaths, ":"))
    env = prependEnvVar(env, "PATH", strings.Join(binPaths, ":"))
    env = prependEnvVar(env, "PKG_CONFIG_PATH", strings.Join(pkgConfigPaths, ":"))
    
    return env
}

// GenerateActivateScript generates a shell script to activate this environment
func (e *Environment) GenerateActivateScript() string {
    var script strings.Builder
    
    script.WriteString("#!/bin/bash\n")
    script.WriteString("# Generated by upkg\n\n")
    
    libPaths := e.GetLibraryPaths()
    includePaths := e.GetIncludePaths()
    binPaths := e.GetBinaryPaths()
    pkgConfigPaths := e.GetPkgConfigPaths()
    
    if len(libPaths) > 0 {
        script.WriteString(fmt.Sprintf("export LD_LIBRARY_PATH=\"%s:$LD_LIBRARY_PATH\"\n", strings.Join(libPaths, ":")))
        script.WriteString(fmt.Sprintf("export LIBRARY_PATH=\"%s:$LIBRARY_PATH\"\n", strings.Join(libPaths, ":")))
    }
    
    if len(includePaths) > 0 {
        script.WriteString(fmt.Sprintf("export C_INCLUDE_PATH=\"%s:$C_INCLUDE_PATH\"\n", strings.Join(includePaths, ":")))
        script.WriteString(fmt.Sprintf("export CPLUS_INCLUDE_PATH=\"%s:$CPLUS_INCLUDE_PATH\"\n", strings.Join(includePaths, ":")))
    }
    
    if len(binPaths) > 0 {
        script.WriteString(fmt.Sprintf("export PATH=\"%s:$PATH\"\n", strings.Join(binPaths, ":")))
    }
    
    if len(pkgConfigPaths) > 0 {
        script.WriteString(fmt.Sprintf("export PKG_CONFIG_PATH=\"%s:$PKG_CONFIG_PATH\"\n", strings.Join(pkgConfigPaths, ":")))
    }
    
    return script.String()
}

// Exists checks if the environment's install path exists
func (e *Environment) Exists() bool {
    return dirExists(e.InstallPath)
}

// Helper functions

func dirExists(path string) bool {
    info, err := os.Stat(path)
    return err == nil && info.IsDir()
}

func fileExists(path string) bool {
    info, err := os.Stat(path)
    return err == nil && !info.IsDir()
}

func prependEnvVar(environ []string, key, value string) []string {
    if value == "" {
        return environ
    }
    
    prefix := key + "="
    found := false
    
    for i, env := range environ {
        if strings.HasPrefix(env, prefix) {
            // Prepend to existing value
            existing := env[len(prefix):]
            if existing != "" {
                environ[i] = prefix + value + ":" + existing
            } else {
                environ[i] = prefix + value
            }
            found = true
            break
        }
    }
    
    if !found {
        // Add new variable
        environ = append(environ, prefix+value)
    }
    
    return environ
}